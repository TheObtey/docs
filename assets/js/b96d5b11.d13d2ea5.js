"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[8825],{40856:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=n(85893),a=n(11151);const i={title:"Compatibility Versions",description:"How to update your packages to the new Compatibility Versions",tags:["scripting","migration"]},c=void 0,r={id:"core-concepts/packages/compatibility-versions",title:"Compatibility Versions",description:"How to update your packages to the new Compatibility Versions",source:"@site/docs/core-concepts/packages/compatibility-versions.md",sourceDirName:"core-concepts/packages",slug:"/core-concepts/packages/compatibility-versions",permalink:"/docs/next/core-concepts/packages/compatibility-versions",draft:!1,unlisted:!1,editUrl:"https://github.com/nanos-world/docs/edit/master/docs/core-concepts/packages/compatibility-versions.md",tags:[{label:"scripting",permalink:"/docs/next/tags/scripting"},{label:"migration",permalink:"/docs/next/tags/migration"}],version:"current",lastUpdatedBy:"Gabriel T. Nardy",lastUpdatedAt:1706291473,formattedLastUpdatedAt:"Jan 26, 2024",frontMatter:{title:"Compatibility Versions",description:"How to update your packages to the new Compatibility Versions",tags:["scripting","migration"]},sidebar:"main",previous:{title:"Loading Screen",permalink:"/docs/next/core-concepts/packages/loading-screen"},next:{title:"Classes Guide",permalink:"/docs/next/core-concepts/scripting/classes-guide"}},o={},l=[{value:"All Updates",id:"all-updates",level:2},{value:"Version <code>1.55</code>",id:"version-155",level:3},{value:"Assets.GetX()",id:"assetsgetx",level:4},{value:"Version <code>1.54</code>",id:"version-154",level:3},{value:"Level.CallLevelBlueprintEvent()",id:"levelcalllevelblueprintevent",level:4},{value:"Client.GetPackages()",id:"clientgetpackages",level:4},{value:"Version <code>1.49</code>",id:"version-149",level:3},{value:"Package.GetName()",id:"packagegetname",level:4},{value:"Server.GetMap()",id:"servergetmap",level:4},{value:"Server.GetPackages()",id:"servergetpackages",level:4},{value:"Version <code>1.33</code>",id:"version-133",level:3},{value:"Input.GetScriptingKeyBindings() and Input.GetGameKeyBindings()",id:"inputgetscriptingkeybindings-and-inputgetgamekeybindings",level:4},{value:"Version <code>1.29</code>",id:"version-129",level:3},{value:"HTTP.Select()",id:"httpselect",level:4},{value:"Database()",id:"database",level:4},{value:"Version <code>1.22</code>",id:"version-122",level:3},{value:"Events.Subscribe()",id:"eventssubscribe",level:4}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"How to update your packages to the new Compatibility Versions"}),"\n",(0,s.jsx)(t.p,{children:"The Compatibility Version is meant to assure your packages will not break in future breaking changes updates."}),"\n",(0,s.jsx)(t.p,{children:"It works by forcing that package to run code in a compatibility mode, meaning that breaking changes will keep working as the way it was before. Example:"}),"\n",(0,s.jsx)(t.p,{children:"Let's say you have this code running right now:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'-- Make an asynchronous HTTP request\nHTTP.Request("https://api.nanos.world/", "store/v1/packages/halloween", "GET", "", "application/json", false, {}, function(status, data)\n    -- Do something with my data\nend)\n'})}),"\n",(0,s.jsxs)(t.p,{children:["And then, in the hypothetical update ",(0,s.jsx)(t.code,{children:"9.99"})," the API changes and make ",(0,s.jsx)(t.code,{children:"HTTP.RequestSync"})," to become ",(0,s.jsx)(t.code,{children:"HTTP.Request"})," and ",(0,s.jsx)(t.code,{children:"HTTP.Request"})," to become ",(0,s.jsx)(t.code,{children:"HTTP.RequestAsync"}),". I.e. you need to update your code to use ",(0,s.jsx)(t.code,{children:"HTTP.RequestAsync"})," now, this is a breaking change as the new functions uses the same name as before."]}),"\n",(0,s.jsxs)(t.p,{children:["With compatibility version, your scripts can keep working as it was before this update, as your ",(0,s.jsx)(t.code,{children:"compatibility_version"})," in your Package.toml will still be set to the older version (i.e. ",(0,s.jsx)(t.code,{children:"9.98"}),", lower than the last version ",(0,s.jsx)(t.code,{children:"9.99"})," which changed it)."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsx)(t.p,{children:"The Compatibility Mode is a feature that aims to keep old and unmaintained packages/game-modes to keep working for a longer time. But from time to time all the deprecated compatibility modes will be removed from the codebase. So always keep your packages up-to-date!"})}),"\n",(0,s.jsx)(t.h2,{id:"all-updates",children:"All Updates"}),"\n",(0,s.jsxs)(t.p,{children:["To use the following features, you must update your Package's ",(0,s.jsx)(t.code,{children:"compatibility_version"})," setting in the Package.toml to at least that version (exact that version or bigger)."]}),"\n",(0,s.jsxs)(t.h3,{id:"version-155",children:["Version ",(0,s.jsx)(t.code,{children:"1.55"})]}),"\n",(0,s.jsx)(t.h4,{id:"assetsgetx",children:(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/assets",children:"Assets.GetX()"})}),"\n",(0,s.jsxs)(t.p,{children:["Before, any ",(0,s.jsx)(t.code,{children:"Assets.GetX()"})," method returned an array of strings. Now it returns an array of tables, containing at least the ",(0,s.jsx)(t.code,{children:"key"})," field on it. See more about this change in the ",(0,s.jsx)(t.a,{href:"/docs/next/core-concepts/assets#asset-meta-data",children:"Assets Meta Data page"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",metastring:'title="Before"',children:'for _, asset in pairs(Assets.GetStaticMeshes("nanos-world")) do\n\tlocal key = asset\nend\n'})}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",metastring:'title="After"',children:'for _, asset in pairs(Assets.GetStaticMeshes("nanos-world")) do\n\tlocal key = asset.key\n\tlocal my_meta_data = asset.my_meta_data\n\tlocal my_random_value = asset.my_random_value\n\t...\nend\n'})}),"\n",(0,s.jsxs)(t.h3,{id:"version-154",children:["Version ",(0,s.jsx)(t.code,{children:"1.54"})]}),"\n",(0,s.jsx)(t.h4,{id:"levelcalllevelblueprintevent",children:(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/level#static-function-calllevelblueprintevent",children:"Level.CallLevelBlueprintEvent()"})}),"\n",(0,s.jsxs)(t.p,{children:["Before, ",(0,s.jsx)(t.code,{children:"Level.CallLevelBlueprintEvent()"})," expected a string with the function name and parameters concatenated together separated by spaces. Now it uses the new approach of receiving a variadic amount of parameters and also returns the function return value."]}),"\n",(0,s.jsx)(t.h4,{id:"clientgetpackages",children:(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/client#static-function-getpackages",children:"Client.GetPackages()"})}),"\n",(0,s.jsxs)(t.p,{children:["Before, ",(0,s.jsx)(t.code,{children:"Client.GetPackages()"})," returned all packages that the server was running on client side. Now it behaves exactly like ",(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/server#static-function-getpackages",children:"Server.GetPackages()"}),", having a filter as parameter and providing more information on return."]}),"\n",(0,s.jsxs)(t.h3,{id:"version-149",children:["Version ",(0,s.jsx)(t.code,{children:"1.49"})]}),"\n",(0,s.jsx)(t.h4,{id:"packagegetname",children:(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/package#static-function-getname",children:"Package.GetName()"})}),"\n",(0,s.jsxs)(t.p,{children:["Before, ",(0,s.jsx)(t.code,{children:"Package.GetName()"})," was returning the title defined in Package.toml. Now it is standardized and it returns the Path of the Package (the real Name of it). Also ",(0,s.jsx)(t.code,{children:"Package.GetPath()"})," was deprecated in favor of ",(0,s.jsx)(t.code,{children:"Package.GetName()"}),"."]}),"\n",(0,s.jsx)(t.h4,{id:"servergetmap",children:(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/server#static-function-getmap",children:"Server.GetMap()"})}),"\n",(0,s.jsxs)(t.p,{children:["Before, ",(0,s.jsx)(t.code,{children:"Server.GetMap()"})," was returning the map asset defined in Config.toml. Now as we can load Map Packages, it will start returning the Map Package name instead. In compatibility mode it will still return the Map Asset. If you want to still keep retrieving the Map asset, please use the new method ",(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/server#static-function-getmapasset",children:"Server.GetMapAsset()"})," instead."]}),"\n",(0,s.jsx)(t.h4,{id:"servergetpackages",children:(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/server#static-function-getpackages",children:"Server.GetPackages()"})}),"\n",(0,s.jsxs)(t.p,{children:["Before, ",(0,s.jsx)(t.code,{children:"Package.GetPackages(only_loaded)"})," returned a list of strings containing all the package names. Now it has a new parameter (",(0,s.jsx)(t.code,{children:"package_type_filter"}),") and returns a list of table with the Packages information:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'local packages = Package.GetPackages(only_loaded, package_type_filter)\n--[[\n\t{\n\t\t{\n\t\t\t["title"] = "Awesome Package",\n\t\t\t["name"] = "awesome-package",\n\t\t\t["type"] = PackageType.Script,\n\t\t\t["version"] = "1.0.0",\n\t\t\t["author"] = "Myself",\n\t\t},\n\t\t...\n\t}\n--]]\n'})}),"\n",(0,s.jsxs)(t.h3,{id:"version-133",children:["Version ",(0,s.jsx)(t.code,{children:"1.33"})]}),"\n",(0,s.jsxs)(t.h4,{id:"inputgetscriptingkeybindings-and-inputgetgamekeybindings",children:[(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/input#static-function-getscriptingkeybindings",children:"Input.GetScriptingKeyBindings()"})," and ",(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/input#static-function-getgamekeybindings",children:"Input.GetGameKeyBindings()"})]}),"\n",(0,s.jsx)(t.p,{children:"Before those methods returned a table in the format (example):"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'-- KeyBinding = Key\n{\n\t"Jump" = "Spacebar",\n\t"Crouch" = "Control",\n\t"Fire" = "LeftMouse",\n}\n'})}),"\n",(0,s.jsx)(t.p,{children:"Now it returns in the format (example):"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'-- KeyBinding = { Key, Key, ... }\n{\n\t"Jump" = { "Spacebar", "O" },\n\t"Crouch" = { "Control" },\n\t"Fire" = { "LeftMouse", "Return" },\n}\n'})}),"\n",(0,s.jsxs)(t.h3,{id:"version-129",children:["Version ",(0,s.jsx)(t.code,{children:"1.29"})]}),"\n",(0,s.jsx)(t.h4,{id:"httpselect",children:(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/http#static-function-select",children:"HTTP.Select()"})}),"\n",(0,s.jsxs)(t.p,{children:["Before ",(0,s.jsx)(t.code,{children:"HTTP.Select"})," was an async method, and since 1.29 it works as a Sync method, not having the callback parameter anymore."]}),"\n",(0,s.jsx)(t.h4,{id:"database",children:(0,s.jsxs)(t.a,{href:"/docs/next/scripting-reference/classes/database#function-execute",children:["Database",":Execute","()"]})}),"\n",(0,s.jsxs)(t.p,{children:["Before ",(0,s.jsx)(t.code,{children:"Database:Execute"})," was an async method, and since 1.29 it works as a Sync method, not having the callback parameter anymore."]}),"\n",(0,s.jsxs)(t.h3,{id:"version-122",children:["Version ",(0,s.jsx)(t.code,{children:"1.22"})]}),"\n",(0,s.jsxs)(t.p,{children:["In version 1.22 we introduced the concept of ",(0,s.jsx)(t.a,{href:"/docs/next/core-concepts/packages/packages-guide#compatibility-version",children:"Compatibility Version"}),". Besides that, we've got just one breaking change:"]}),"\n",(0,s.jsx)(t.h4,{id:"eventssubscribe",children:(0,s.jsx)(t.a,{href:"/docs/next/scripting-reference/static-classes/events#static-function-subscribe",children:"Events.Subscribe()"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"Events.Subscribe"})," now only subscribes to local events (ones called as ",(0,s.jsx)(t.strong,{children:"Events.Call"}),"). If you want to subscribe to remote events (ones called as ",(0,s.jsx)(t.strong,{children:"Events.CallRemote"})," or ",(0,s.jsx)(t.strong,{children:"Events.BroadcastRemote"}),"), please use ",(0,s.jsx)(t.code,{children:"Events.SubscribeRemote"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["In compatibility mode (i.e. setting it to ",(0,s.jsx)(t.code,{children:"1.21"})," or below) ",(0,s.jsx)(t.code,{children:"Events.Subscribe"})," still subscribes for both Local and Remote events."]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>c});var s=n(67294);const a={},i=s.createContext(a);function c(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);