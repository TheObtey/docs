"use strict";(self.webpackChunkdocs_docusaurus=self.webpackChunkdocs_docusaurus||[]).push([[6971],{9711:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var o=n(85893),s=n(11151);const a={title:"Tra\xe7os & Raycasting",description:"Como usar trilhas & Raycasting para coletar informa\xe7\xf5es do mundo em tempo de execu\xe7\xe3o",sidebar_position:7,tags:["script"]},i=void 0,r={id:"core-concepts/scripting/traces-and-raycasting",title:"Tra\xe7os & Raycasting",description:"Como usar trilhas & Raycasting para coletar informa\xe7\xf5es do mundo em tempo de execu\xe7\xe3o",source:"@site/i18n/pt-BR/docusaurus-plugin-content-docs/version-latest/core-concepts/scripting/traces-and-raycasting.md",sourceDirName:"core-concepts/scripting",slug:"/core-concepts/scripting/traces-and-raycasting",permalink:"/pt-BR/docs/core-concepts/scripting/traces-and-raycasting",draft:!1,unlisted:!1,editUrl:"https://crowdin.com/project/nanos-world-docs/pt-BR",tags:[{inline:!0,label:"script",permalink:"/pt-BR/docs/tags/script"}],version:"latest",sidebarPosition:7,frontMatter:{title:"Tra\xe7os & Raycasting",description:"Como usar trilhas & Raycasting para coletar informa\xe7\xf5es do mundo em tempo de execu\xe7\xe3o",sidebar_position:7,tags:["script"]},sidebar:"main",previous:{title:"Intelig\xeancia Artificial",permalink:"/pt-BR/docs/core-concepts/scripting/artificial-intelligence"},next:{title:"Extending Classes",permalink:"/pt-BR/docs/core-concepts/scripting/extending-classes"}},c={},l=[];function d(e){const t={a:"a",admonition:"admonition",code:"code",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"Como usar trilhas & Raycasting para coletar informa\xe7\xf5es do mundo em tempo de execu\xe7\xe3o."}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Traces"})," oferecem um m\xe9todo para alcan\xe7ar seus mapas e obter feedback sobre o que est\xe1 presente ao longo de um segmento de linha. You use them by providing two end points (a start and end location) and the physics system \u201ctraces\u201d a line segment between those points, reporting any Actors that it hits. As trilhas s\xe3o essencialmente as mesmas que ",(0,o.jsx)(t.strong,{children:"Raycasts"})," ou ",(0,o.jsx)(t.strong,{children:"Raytraces"})," em outros pacotes de software."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(39341).Z+"",width:"1152",height:"435"})}),"\n",(0,o.jsx)(t.p,{children:"O exemplo a seguir mostrar\xe1 como obter o qu\xea e para onde o jogador est\xe1 olhando."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-lua",metastring:'title="Client/Index.lua"',children:'-- Traces at each 100ms\nTimer.SetInterval(function()\n    -- Gets the middle of the screen\n    local viewport_2D_center = Viewport.GetViewportSize() / 2\n\n    -- Deprojects to get the 3D Location for the middle of the screen\n    local viewport_3D = Viewport.DeprojectScreenToWorld(viewport_2D_center)\n\n    -- Makes a trace with the 3D Location and it\'s direction multiplied by 5000\n    -- Meaning it will trace 5000 units in that direction\n    local trace_max_distance = 5000\n\n    local start_location = viewport_3D.Position\n    local end_location = viewport_3D.Position + viewport_3D.Direction * trace_max_distance\n\n    -- Determine at which object we will be tracing for (WorldStatic - StaticMeshes - and PhysicsBody - Props)\n    local collision_trace = CollisionChannel.WorldStatic | CollisionChannel.PhysicsBody\n\n    -- Sets the trace modes (we want it to return Entity and Draws a Debug line)\n    local trace_mode = TraceMode.ReturnEntity | TraceMode.DrawDebug\n\n    -- Last parameter as true means it will draw a Debug Line in the traced segment\n    local trace_result = Trace.LineSingle(start_location, end_location, collision_trace, trace_mode)\n\n    -- If hit something draws a Debug Point at the location\n    if (trace_result.Success) then\n\n        -- Makes the point Red or Green if hit an Actor\n        local color = Color(1, 0, 0) -- Red\n\n        if (trace_result.Entity) then\n            color = Color(0, 1, 0) -- Green\n\n            -- Here you can check which actor you hit like\n            -- if (trace_result.Entity:GetType() == "Character") then ...\n        end\n\n        -- Draws a Debug Point at the Hit location for 5 seconds with size 10\n        Debug.DrawPoint(trace_result.Location, color, 5, 10)\n    end\nend, 100)\n'})}),"\n",(0,o.jsx)(t.admonition,{type:"tip",children:(0,o.jsxs)(t.p,{children:["As you could see, we can pass bit-wise operators to Trace for more than one ",(0,o.jsx)(t.a,{href:"/pt-BR/docs/scripting-reference/glossary/enums#collisionchannel",children:"CollisionChannel"})," at once! Use ",(0,o.jsx)(t.code,{children:"\u27b2"})," entre os ",(0,o.jsx)(t.strong,{children:"CollisionChannels"})," para conseguir isso."]})})]})}function p(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},39341:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/traces-raycasting-fad2ddd4424e6c9b19e682b88acf4371.webp"},11151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>i});var o=n(67294);const s={},a=o.createContext(s);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);